<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jigang-branding Geumsan Insam</title>
    <link rel="stylesheet" href="css/branding.css">
</head>
<body>
<!-- header시작------------------------------------------------ -->
    <header>
        <div class="wrap">
            <h1>
                <a href="index.html">Jigang Portforlio</a>
            </h1>
            <ul>
                <li><a href="index.html">About</a></li>
                <li><a href="index.html">Projects</a></li>
                <li><a href="index.html">Contact</a></li>
            </ul>
        </div>
    </header>
<!-- header끝------------------------------------------------ -->

<section>
    <div class="wrap">
        <img src="img/branding-03.jpg" alt="해피바스">
    </div>
</section>





<script src="https://unpkg.com/aos@2.3.1/dist/aos.js"></script>

<script>
  AOS.init();





  



  // script.js — injects mobile hamburger + drawer and moves existing header ul into the drawer
// Only active when viewport width <= 500px. On resize it enables/disables accordingly.
// Behavior: when enabled it moves the existing <ul> into the drawer; when disabled it restores it.

document.addEventListener('DOMContentLoaded', function () {
  const header = document.querySelector('header');
  const headerWrap = header && header.querySelector('.wrap');
  if (!header || !headerWrap) return;

  // find existing menu UL inside header.wrap (may be null)
  const menuUl = headerWrap.querySelector('ul') || null;

  // Save original parent & nextSibling so we can restore the menu later
  const originalParent = menuUl ? menuUl.parentNode : null;
  const originalNextSibling = menuUl ? menuUl.nextSibling : null;

  // state
  let enabled = false;
  let hamburger, overlay, drawer, closeBtn;

  // NAV_DELAY should match CSS transition duration (~280ms)
  const NAV_DELAY = 260;

  // create DOM nodes and attach behavior
  function enableMobileDrawer() {
    if (enabled) return;
    // Do not enable if elements already exist
    if (document.querySelector('.mobile-hamburger') || document.querySelector('.mobile-drawer')) {
      enabled = true;
      return;
    }

    // create hamburger button
    hamburger = document.createElement('button');
    hamburger.className = 'mobile-hamburger';
    hamburger.type = 'button';
    hamburger.setAttribute('aria-label', '메뉴 열기');
    hamburger.setAttribute('aria-expanded', 'false');
    hamburger.innerHTML = '<span class="bar" aria-hidden="true"></span>';

    // create overlay
    overlay = document.createElement('div');
    overlay.className = 'drawer-overlay';
    overlay.setAttribute('aria-hidden', 'true');
    overlay.tabIndex = -1;

    // create drawer
    drawer = document.createElement('div');
    drawer.className = 'mobile-drawer';
    drawer.id = 'mobile-drawer';
    drawer.setAttribute('aria-hidden', 'true');

    // create close button inside drawer
    closeBtn = document.createElement('button');
    closeBtn.className = 'drawer-close';
    closeBtn.type = 'button';
    closeBtn.setAttribute('aria-label', '메뉴 닫기');
    closeBtn.innerHTML = '&times;';

    // assemble drawer content: close button + moved menu (if exists) or fallback
    drawer.appendChild(closeBtn);
    if (menuUl) {
      drawer.appendChild(menuUl);
    } else {
      const nav = document.createElement('nav');
      nav.innerHTML = '<ul><li><a href="#">메뉴 없음</a></li></ul>';
      drawer.appendChild(nav);
    }

    // insert overlay and drawer into DOM (after header)
    header.parentNode.insertBefore(overlay, header.nextSibling);
    header.parentNode.insertBefore(drawer, overlay.nextSibling);

    // insert hamburger into header.wrap (as first child so it sits on left)
    headerWrap.insertBefore(hamburger, headerWrap.firstChild);

    // open/close functions
    function openDrawer() {
      drawer.classList.add('open');
      overlay.classList.add('open');
      hamburger.setAttribute('aria-expanded', 'true');
      drawer.setAttribute('aria-hidden', 'false');
      overlay.setAttribute('aria-hidden', 'false');
      // focus the close button for accessibility
      closeBtn.focus();
      document.documentElement.style.overflow = 'hidden';
    }
    function closeDrawer() {
      drawer.classList.remove('open');
      overlay.classList.remove('open');
      hamburger.setAttribute('aria-expanded', 'false');
      drawer.setAttribute('aria-hidden', 'true');
      overlay.setAttribute('aria-hidden', 'true');
      hamburger.focus();
      document.documentElement.style.overflow = '';
    }

    // event listeners
    hamburger.addEventListener('click', function () {
      const expanded = this.getAttribute('aria-expanded') === 'true';
      if (expanded) closeDrawer();
      else openDrawer();
    });
    overlay.addEventListener('click', closeDrawer);
    closeBtn.addEventListener('click', closeDrawer);

    // close on ESC
    document.addEventListener('keydown', function (e) {
      if (e.key === 'Escape' && drawer.classList.contains('open')) {
        closeDrawer();
      }
    });

    // NEW: when a link inside the drawer is clicked, close the drawer and then navigate.
    drawer.addEventListener('click', function (e) {
      const target = e.target;
      const anchor = target.closest && target.closest('a');
      if (!anchor) return;

      const href = anchor.getAttribute('href') || '';
      e.preventDefault();

      // Close drawer first
      closeDrawer();

      // Delay navigation so close animation can play
      setTimeout(function () {
        if (!href || href === '#' || href.trim() === '') {
          return;
        }
        if (href.charAt(0) === '#') {
          const targetEl = document.querySelector(href);
          if (targetEl) {
            try {
              targetEl.scrollIntoView({ behavior: 'smooth' });
            } catch (err) {
              location.hash = href;
            }
          } else {
            location.hash = href;
          }
        } else {
          const targetAttr = anchor.getAttribute('target');
          if (targetAttr && targetAttr.toLowerCase() === '_blank') {
            window.open(href, '_blank');
          } else {
            window.location.href = href;
          }
        }
      }, NAV_DELAY);
    });

    // close drawer automatically if viewport becomes wider than 500px
    // (this listener can exist whether enabled or not; it simply ensures proper cleanup)
    enabled = true;
  }

  // remove DOM nodes and restore menu to original place
  function disableMobileDrawer() {
    if (!enabled) return;

    // If drawer is open, force-close
    const existingDrawer = document.querySelector('.mobile-drawer');
    if (existingDrawer && existingDrawer.classList.contains('open')) {
      existingDrawer.classList.remove('open');
    }
    const existingOverlay = document.querySelector('.drawer-overlay');
    if (existingOverlay) {
      existingOverlay.classList.remove('open');
    }
    document.documentElement.style.overflow = '';

    // Move menuUl back to original parent if it was moved
    if (menuUl && originalParent) {
      try {
        originalParent.insertBefore(menuUl, originalNextSibling);
      } catch (err) {
        // fallback: append if insertBefore fails
        originalParent.appendChild(menuUl);
      }
    }

    // Remove injected elements if present
    const hb = document.querySelector('.mobile-hamburger');
    const dr = document.querySelector('.mobile-drawer');
    const ov = document.querySelector('.drawer-overlay');
    if (hb && hb.parentNode) hb.parentNode.removeChild(hb);
    if (dr && dr.parentNode) dr.parentNode.removeChild(dr);
    if (ov && ov.parentNode) ov.parentNode.removeChild(ov);

    // Reset references
    hamburger = overlay = drawer = closeBtn = null;
    enabled = false;
  }

  // track current window state and toggle accordingly
  function checkAndToggle() {
    const shouldEnable = window.innerWidth <= 500;
    if (shouldEnable && !enabled) {
      enableMobileDrawer();
    } else if (!shouldEnable && enabled) {
      disableMobileDrawer();
    }
  }

  // initial check
  checkAndToggle();

  // listen for resize and toggle when crossing the 500px threshold
  let lastWidth = window.innerWidth;
  window.addEventListener('resize', function () {
    const currentWidth = window.innerWidth;
    // only act when crossing the 500px breakpoint to avoid thrash
    if ((lastWidth > 500 && currentWidth <= 500) || (lastWidth <= 500 && currentWidth > 500)) {
      checkAndToggle();
    }
    lastWidth = currentWidth;
  });
});
</script>

</body>
</html>